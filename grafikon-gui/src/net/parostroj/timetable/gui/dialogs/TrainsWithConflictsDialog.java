/*
 * TrainsWithConflictsDialog.java
 *
 * Created on 24. Ãºnor 2008, 11:01
 */
package net.parostroj.timetable.gui.dialogs;

import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import javax.swing.AbstractListModel;
import net.parostroj.timetable.actions.TrainComparator;
import net.parostroj.timetable.gui.AppPreferences;
import net.parostroj.timetable.gui.ApplicationModel;
import net.parostroj.timetable.gui.ApplicationModelEvent;
import net.parostroj.timetable.gui.ApplicationModelListener;
import net.parostroj.timetable.gui.StorableGuiData;
import net.parostroj.timetable.gui.helpers.TrainWrapper;
import net.parostroj.timetable.model.Train;
import net.parostroj.timetable.utils.ResourceLoader;

/**
 * Dialog for showing trains with conflicts ...
 * 
 * @author jub
 */
public class TrainsWithConflictsDialog extends javax.swing.JDialog implements ApplicationModelListener, StorableGuiData {
    
    private ApplicationModel model;
    
    private TrainComparator comparator;
    
    /** Creates new form TrainsWithConflictsDialog */
    public TrainsWithConflictsDialog(java.awt.Frame parent, boolean modal) {
        super(parent, modal);
        initComponents();
    }
    
    public void setModel(ApplicationModel model) {
        this.model = model;
        model.addListener(this);
    }
    
    @Override
    public void modelChanged(ApplicationModelEvent event) {
        switch (event.getType()) {
            case DELETE_TRAIN:
                this.removeTrain((Train)event.getObject());
                break;
            case MODIFIED_TRAIN:
                this.updateTrain((Train)event.getObject());
                break;
            case NEW_TRAIN:
                this.updateTrain((Train)event.getObject());
                break;
            case SELECTED_TRAIN_CHANGED:
                this.updateSelectedTrain((Train)event.getObject());
                break;
            case SET_DIAGRAM_CHANGED:
                // update all trains
                updateAllTrains();
                break;
        }
    }
    
    private void updateSelectedTrain(Train train) {
        Train listT = (((TrainWrapper)trainsList.getSelectedValue()) != null) ? ((TrainWrapper)trainsList.getSelectedValue()).getElement() : null;
        if (train == listT)
            return;
        else if (train == null) {
            trainsList.getSelectionModel().clearSelection();
        } else {
            int index = ((TrainsListModel)trainsList.getModel()).getIndex(train);
            if (index >= 0)
                trainsList.setSelectedIndex(index);
            else
                trainsList.getSelectionModel().clearSelection();
        }
    }
    
    private void updateAllTrains() {
        TrainsListModel tModel = (TrainsListModel)trainsList.getModel();
        tModel.clear();
        if (model.getDiagram() != null) {
            comparator = new TrainComparator(TrainComparator.Type.ASC, model.getDiagram().getTrainsData().getTrainSortPattern());
            for (Train train : model.getDiagram().getTrains()) {
                if (train.isConflicting()) {
                    tModel.add(train, comparator);
                }
            }
        }
    }
    
    private void updateTrain(Train train) {
        TrainsListModel tModel = (TrainsListModel)trainsList.getModel();
        if (train.isConflicting()) {
            tModel.add(train, comparator);
            for (Train t : train.getConflictingTrains()) {
                tModel.add(t, comparator);
            }
        }
        this.checkTrains();
    }
    
    private void removeTrain(Train train) {
        TrainsListModel tModel = (TrainsListModel)trainsList.getModel();
        tModel.remove(train);
        this.checkTrains();
    }
    
    private void checkTrains() {
        TrainsListModel tModel = (TrainsListModel)trainsList.getModel();
        Set<Train> removed = null;
        for (Iterator<Train> i = tModel.iterator(); i.hasNext();) {
            Train t = i.next();
            if (!t.isConflicting()) {
                if (removed == null)
                    removed = new HashSet<Train>();
                removed.add(t);
            }
        }
        if (removed != null) {
            for (Train t : removed)
                tModel.remove(t);
        }
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        scrollPane = new javax.swing.JScrollPane();
        trainsList = new javax.swing.JList();

        setTitle(ResourceLoader.getString("dialog.trainconflicts.title")); // NOI18N
        setFocusableWindowState(false);
        setLocationByPlatform(true);

        trainsList.setModel(new TrainsListModel());
        trainsList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_INTERVAL_SELECTION);
        trainsList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                trainsListValueChanged(evt);
            }
        });
        scrollPane.setViewportView(trainsList);

        getContentPane().add(scrollPane, java.awt.BorderLayout.CENTER);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void trainsListValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_trainsListValueChanged
        // selected train ...
        if (!evt.getValueIsAdjusting()) {
            TrainWrapper wrapper = (TrainWrapper)trainsList.getSelectedValue();
            if (wrapper != null) {
                Train train = wrapper.getElement();
                if (train != model.getSelectedTrain()) {
                    model.setSelectedTrain(train);
                }
            }
        }
    }//GEN-LAST:event_trainsListValueChanged
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane scrollPane;
    private javax.swing.JList trainsList;
    // End of variables declaration//GEN-END:variables

    @Override
    public void saveToPreferences(AppPreferences prefs) {
        prefs.setInt("train.conflicts.x", this.getX());
        prefs.setInt("train.conflicts.y", this.getY());
        prefs.setInt("train.conflicts.width", this.getWidth());
        prefs.setInt("train.conflicts.height", this.getHeight());
    }

    @Override
    public void loadFromPreferences(AppPreferences prefs) {
        if ((prefs.getInt("train.conflicts.x") == null) ||
                (prefs.getInt("train.conflicts.y") == null) ||
                (prefs.getInt("train.conflicts.width") == null) ||
                (prefs.getInt("train.conflicts.height") == null)) {
            return;
        }
        Rectangle r = new Rectangle(prefs.getInt("train.conflicts.x"), prefs.getInt("train.conflicts.y"),
                prefs.getInt("train.conflicts.width"), prefs.getInt("train.conflicts.height"));
        // set position and size
        this.setBounds(r);
    }
}
class TrainsListModel extends AbstractListModel {
    
    private List<Train> trains = new ArrayList<Train>();
    
    public void remove(Train train) {
        int index = trains.indexOf(train);
        if (index != -1) {
            trains.remove(train);
            this.fireIntervalRemoved(this, index, index);
        }
    }
    
    public void add(Train train, TrainComparator comparator) {
        for (int i=0; i< trains.size(); i++) {
            int compare = comparator.compare(train, trains.get(i));
            if (compare < 0) {
                trains.add(i, train);
                this.fireIntervalAdded(this, i, i);
                return;
            } else if (compare == 0)
                // do not insert duplicate train ...
                return;
        }
        // the train will be added at the end of the list
        trains.add(train);
        this.fireIntervalAdded(this, trains.size() - 1, trains.size() - 1);
    }
    
    public void clear() {
        int size = trains.size();
        trains.clear();
        if (size > 0)
            this.fireIntervalRemoved(this, 0, size - 1);
    }

    @Override
    public int getSize() {
        return trains.size();
    }
    
    public Iterator<Train> iterator() {
        return trains.iterator();
    }
    
    public int getIndex(Train train) {
        return trains.indexOf(train);
    }

    @Override
    public Object getElementAt(int index) {
        return new TrainWrapper(trains.get(index), TrainWrapper.Type.NAME_AND_END_NODES_WITH_TIME);
    }
}